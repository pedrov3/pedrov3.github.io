<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pedrov3.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Pesquisando...","empty":"Não encontramos nenhum resultado para a pesquisa: ${query}","hits_time":"${hits} resultados encontrados em ${time} ms","hits":"${hits} resultados encontrados"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://pedrov3.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="pt_BR">
<meta property="article:author" content="Pedro Vinicius Sousa da Silva">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://pedrov3.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"pt-BR","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Alternar barra de navegação" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Pesquisar" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>Sobre</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Arquivos</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Pesquisar
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Pesquisando..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Índice
        </li>
        <li class="sidebar-nav-overview">
          Visão geral
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pedro Vinicius Sousa da Silva</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">publicações</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">etiquetas</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pedrov3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pedrov3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/pedroestouaqui@gmail.com" title="E-Mail → pedroestouaqui@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://pedrov3.github.io/2024/04/24/Testando-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pedro Vinicius Sousa da Silva">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/Testando-1/" class="post-title-link" itemprop="url">Testando</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Postado em</span>
      

      <time title="Criado em: 2024-04-24 21:40:25 / Modificado em: 21:43:15" itemprop="dateCreated datePublished" datetime="2024-04-24T21:40:25-03:00">2024-04-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1 id="Visao-geral"><a href="#Visao-geral" class="headerlink" title="Visão geral"></a>Visão geral</h1><p>Fui inspirado a escrever este post porque tenho visto problemas ao usar o Polynomial Shift em diversas competições recentemente.</p>
<p>Encontrar um novo polinômio $f(x+c)$ dado o polinômio $f(x)$ e o inteiro $c$ é chamado <strong>deslocamento de Taylor</strong>.</p>
<p>Se o polinômio $f(x)$ de grau menor que $N$ estiver oculto e dados os valores $f(0), f(1), \cdots , f(N-1)$ e os inteiros $c$, $M$, então $f(c), f(c +1), \cdots, f(c+M-1)$ é chamado de <strong>deslocamento de pontos de amostragem</strong>.</p>
<p>Os dois problemas acima são frequentemente ferramentas úteis na resolução de problemas combinatórios. Ambos os problemas são muito lentos para serem resolvidos de forma simples, mas podem ser resolvidos de forma eficiente se a FFT for usada.</p>
<p>Este artigo cobre os seguintes tópicos:</p>
<ul>
<li><p>Calculo do deslocamento de Taylor para um polinômio de grau $N$ em $O(N \log N)$</p>
</li>
<li><p>Calcular mudança de pontos de amostragem em $O((N+M) \log (N+M))$</p>
</li>
<li><p>Calcular $(N!\pmod{998244353})$ em $O(\sqrt{N} \log N)$ utilizando o deslocamento de pontos de amostragem.</p>
</li>
<li><p>Resolução de problemas usando deslocamento de Taylor</p>
</li>
</ul>
<p>Este artigo foi escrito para ser fácil de ler, mesmo para aqueles que não sabem como a FFT funciona, neste caso, você pode usá-la como uma caixa preta.</p>
<h2 id="Polynomial-Taylor-Shift"><a href="#Polynomial-Taylor-Shift" class="headerlink" title="Polynomial Taylor Shift"></a><a target="_blank" rel="noopener" href="https://judge.yosupo.jp/problem/polynomial_taylor_shift">Polynomial Taylor Shift</a></h2><h3 id="Problema"><a href="#Problema" class="headerlink" title="Problema"></a>Problema</h3><p>Dada uma sequência $a &#x3D; (a_0, a_1, \cdots, a_{N-1})$ de comprimento $N$ e um inteiro $c$.</p>
<p>Vamos definir um polinômio $f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i x^i$ de grau $N-1$.</p>
<p>O objetivo é encontrar uma sequência $b &#x3D; (b_0, b_1, \cdots, b_{N-1})$ que satisfaz $f(x+c) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} b_i x^i$, como este números podem ser grandes, imprima módulo $998244353$.</p>
<p>Limites: $1 \leq N \leq 2^{19} &#x3D; 524288; 0 \leq c,a_i &lt; 998244353$</p>
<h3 id="Solucao"><a href="#Solucao" class="headerlink" title="Solução"></a>Solução</h3><p>O cálculo ingênuo em $O(N^2)$ é muito lento. Vamos expandir $f(x+c)$ e otimizá-lo através de várias manipulações de somatório para resolver em $O(n \log N)$.</p>
<p>Pelo teorema binomial:</p>
<p>$(a + b)^n  &#x3D; \sum\limits_{k&#x3D;0}^n\binom{n}{k}a^kb^{n-k}$,</p>
<p>Logo a partir da definição do polinômio $f$, podemos expandir no seguinte:</p>
<p>$f(x+c) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i (x+c)^i &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i  \Big( \sum\limits_ { j&#x3D;0}^{i} \binom{i}{j} x^j c^{i-j} \Big) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} \sum\limits_ { j&#x3D;0}^{i} a_i \binom{i}{j} x^j c^{i-j}&#x3D;$</p>
<p>$ &#x3D; \sum\limits_{i&#x3D;0}^{N-1}\sum\limits_{j&#x3D;0}^{i}a_i \dfrac{i! x^j c^{i-j}}{(i-j)!j!} &#x3D; $</p>
<p>$ &#x3D; \sum\limits_{j&#x3D;0}^{N-1}\sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! x^j c^{i-j}}{(i-j)!j!} &#x3D; $ (A justificativa ilustrada na figura ??).</p>
<p>$ &#x3D; \sum\limits_{j&#x3D;0}^{N-1} \dfrac{x^j}{j!} \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!}$</p>
<p>Este somatório interno pode ser resolvido usando FFT, a explicação segue:</p>
<p>Queremos encontrar $C_j &#x3D; \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!}$ para  $0 \le j \le N-1$.</p>
<p>Para isso seja $A_i &#x3D; a_i \cdot i!$, $B_i &#x3D; \dfrac{c^i}{i!}$</p>
<p>Podemos reescrever $C_j$ como:</p>
<p>$C_j &#x3D; \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!} &#x3D; \sum\limits_{i&#x3D;j}^{N-1} A_i B_{i-j} &#x3D; \sum\limits_{i&#x3D;j}^{N-1}\overline{A}<em>{N-i-1}B</em>{i-j} &#x3D; (\overline{A} * B)_{N - j - 1}$</p>
<p>$\overline{A}$ denota o vetor $A$ revertido (de trás para frente).</p>
<p>Desse modo, podemos computar o vetor $C$ através de uma convolução entre o vetor $\overline{A}$ e $B$ em $O(N \log N)$ usando FFT e depois usar o vetor $C$ para encontrar a sequência $b$, já que $b_j &#x3D; \frac{C_j}{j!} $​.</p>
<h3 id="Codigo"><a href="#Codigo" class="headerlink" title="Código"></a>Código</h3><p><a target="_blank" rel="noopener" href="https://github.com/atcoder/ac-library/blob/master/document_en/convolution.md"><strong>Código de convolução da Biblioteca do Atcoder</strong></a>. O código usado é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atcoder/all&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> <span class="keyword">namespace</span> atcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;mint&gt; <span class="title">taylor_shift</span><span class="params">(vector&lt;mint&gt;&amp; a, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">fat</span><span class="params">(n)</span></span>;</span><br><span class="line">  fat[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    fat[i] = fat[i - <span class="number">1</span>] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">A</span><span class="params">(n)</span>, <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    A[i] = a[i] * fat[i];</span><br><span class="line">    B[i] = <span class="built_in">mint</span>(c).<span class="built_in">pow</span>(i) / fat[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(<span class="built_in">all</span>(A));</span><br><span class="line">  <span class="keyword">auto</span> retval = <span class="built_in">convolution</span>(A, B);</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    b[i] = retval[n - i - <span class="number">1</span>] / fat[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, c;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    a[i] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : <span class="built_in">taylor_shift</span>(a, c)) &#123;</span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Deslocamento-de-pontos-de-amostragem"><a href="#Deslocamento-de-pontos-de-amostragem" class="headerlink" title="Deslocamento de pontos de amostragem"></a><a target="_blank" rel="noopener" href="https://judge.yosupo.jp/problem/shift_of_sampling_points_of_polynomial">Deslocamento de pontos de amostragem</a></h2><h3 id="Problema-1"><a href="#Problema-1" class="headerlink" title="Problema"></a>Problema</h3><p>Um polinômio $f(x)$ de grau menor que $N$ está oculto são dados $N$ valores $f(0), f(1), \cdots, f(N-1)$ e dois inteiros $c ,M$​.</p>
<p>Calcule $f(c + k) \pmod{998244353}$  para $k &#x3D; 0, 1 , \cdots , M - 1$.</p>
<p>$(1 \leq N,M \leq 524288; 0 \leq c,f(i) &lt; 998244353)$</p>
<h3 id="Explicacao"><a href="#Explicacao" class="headerlink" title="Explicação"></a>Explicação</h3><blockquote>
<p> Você pode ver imediatamente que isso pode ser resolvido em $O((N+M) \log^2 (N+M))$ usando Interpolação de Lagrange e Avaliação Multiponto introduzidas em <a target="_blank" rel="noopener" href="https://infossm.github.io/blog/2019/06/16/Multipoint-evaluation/"><strong><a href="Coreano">1</a></strong></a> e no <a target="_blank" rel="noopener" href="https://infossm.github.io/blog/2019/09/14/factor/"><strong><a href="Coreano">2</a></strong></a>. No entanto, resolveremos este problema mais rapidamente, aproveitando as suas propriedades especiais.</p>
</blockquote>
<h4 id="Interpolacao"><a href="#Interpolacao" class="headerlink" title="Interpolação"></a>Interpolação</h4><p>De acordo com a interpolação de Lagrange temos:</p>
<p>$f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} f(i) \prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{x-j}{i-j }$</p>
<p>Note que  $\prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{x-j}{i-j}$ ($0 \leq i,x \leq N-1$) contribui com $1$ apenas quando $x &#x3D; i$, e $0$ caso contrário.</p>
<h4 id="Avaliacao"><a href="#Avaliacao" class="headerlink" title="Avaliação"></a>Avaliação</h4><p>Agora só precisamos encontrar $f(c+k) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} f(i) \prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{c+k-j}{i-j}$ para $0 \leq k &lt; M$​​.</p>
<p>O objetivo é manipular estes somatórios e produtórios de modo que seja possível  gerar essa sequência através da convolução de outras duas sequências.</p>
<p>Para isso</p>
<p>$f(c+k) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} f(i) \prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{c+k-j}{i-j} &#x3D;\sum\limits_{i&#x3D;0}^{N-1}f(i)\dfrac{\dfrac{(c+k) (c + k - 1)\cdots(c+k-(N - 1))}{c+k-i}}{ (-1)^{(N - 1)-i} \cdot i! \cdot ((N - 1) - i)! } \boldsymbol{[c + k - i \neq 0]}&#x3D; $</p>
<p>$ &#x3D; (c+k)(c + k - 1)\cdots(c+k-(N-1)) \cdot \sum\limits_{i&#x3D;0}^{N-1}\dfrac{f(i)}{ (c+k-i) \cdot (-1)^{(N-1)-i} \cdot i!  \cdot ((N-1) - i)! } \boldsymbol{[c + k - i \neq 0]} &#x3D; $</p>
<p>$ &#x3D; \prod\limits_{i&#x3D;0}^{N-1}(c+k-i) \cdot \sum\limits_{i&#x3D;0}^{N-1}\dfrac{f(i)}{ (c+k-i) \cdot (-1)^{(N-1)-i} \cdot i!  \cdot ((N-1) - i)! } \boldsymbol{[c + k - i \neq 0]} &#x3D; $</p>
<p>$ &#x3D; \prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i) \cdot \sum\limits_{i&#x3D;0}^{N-1}\dfrac{f(i)}{ (c+k-i) \cdot (-1)^{(N-1)-i} \cdot i!  \cdot ((N-1) - i)! } \boldsymbol{[c + k - i \neq 0]}$</p>
<p>Podemos ignorar neste momento os produtos externos ao somatório e focar apenas nele. Neste caso podemos resolvê-lo usando FFT.</p>
<p>Se definirmos $A_i &#x3D; \begin{cases} \dfrac{f(i)}{((N-1) - i)! \cdot (-1)^{(N-1) - i} \cdot i!} &amp; j \le N - 1, \ 0 &amp; j &gt; N - 1 \end{cases}$  e</p>
<p>Agora podemos escrever $f(c + k)$ como:</p>
<p>$f(c + k) &#x3D; \prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i)  \sum\limits_{i&#x3D;0}^{N - 1 + k} A_i \cdot \dfrac{1}{(c + k - i)} $</p>
<p>Tomando $B_{N + k - i - 1} &#x3D; \dfrac{1}{c + k - i}$ então $B_i &#x3D; \dfrac{1}{c - N + i}$</p>
<p>Definindo $g(k) &#x3D; \sum\limits_{i&#x3D;0}^{N - 1 + M} A_i \cdot B_{N+k-i-1} &#x3D; (A * B)_{N+k-1}$​ , que está em uma forma computável através de FFT.</p>
<p>Finalizando o cálculo de $f(c + k)$ note que podemos computar o produtório $\prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i)$ em $O(1)$ da seguinte maneira:,</p>
<p>Assumindo que $(C - N + i) \neq 0$, seja $S[i] &#x3D; \prod\limits_{j&#x3D;1}^{i}(C - N + i)$, podemos computar o produtório acima da seguinte maneira $\prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i) &#x3D; \dfrac{S[N + k]}{s[k]}$.</p>
<ul>
<li>não dá pra assumir que $(C - N + i)$ já que pode acontecer</li>
<li>preciso</li>
</ul>
<h3 id="Codigo-1"><a href="#Codigo-1" class="headerlink" title="Código"></a>Código</h3><p>O código está abaixo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atcoder/all&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> atcoder;</span><br><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;mint&gt; <span class="title">sampling_points_shift</span><span class="params">(<span class="type">const</span> vector&lt;mint&gt;&amp; f, mint c, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = f.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">fat</span><span class="params">(n + m)</span>, <span class="title">a</span><span class="params">(n + m)</span>, <span class="title">b</span><span class="params">(n + m)</span>, <span class="title">s</span><span class="params">(n + m)</span>, <span class="title">res</span><span class="params">(m)</span></span>;</span><br><span class="line">  fat[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + m; i++) fat[i] = fat[i - <span class="number">1</span>] * i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">      <span class="type">int</span> sign = ((n - <span class="number">1</span>) - i) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">      a[i] = (sign * f[i]) / (fat[(n - <span class="number">1</span>) - i] * fat[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    b[i] = ((c - n + i + <span class="number">1</span>) == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> / (c - n + i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + m; i++)</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] * <span class="built_in">max</span>((<span class="type">int</span>)(c - n + i).<span class="built_in">val</span>(), (<span class="type">int</span>)<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> retval = <span class="built_in">convolution</span>(a, b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((c + k).<span class="built_in">val</span>() &lt; n) &#123;</span><br><span class="line">      x = (c + k).<span class="built_in">val</span>();</span><br><span class="line">      <span class="keyword">if</span> (x + modint::<span class="built_in">mod</span>() &lt; n) <span class="keyword">continue</span>;<span class="comment">// small mod, two zero case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">-1</span>) res[k] = retval[n + k - <span class="number">1</span>] * s[n + k] / s[k]; <span class="comment">// non-zero case</span></span><br><span class="line">    <span class="keyword">else</span> res[k] = f[x]; <span class="comment">// zero-case</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m, c;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    f[i] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : <span class="built_in">sampling_points_shift</span>(f, c, m)) cout &lt;&lt; x.<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Exemplo-de-uso"><a href="#Exemplo-de-uso" class="headerlink" title="Exemplo de uso"></a>Exemplo de uso</h3><p>Usando deslocamento de pontos de amostragem, $N! \pmod{998244353}$ pode ser obtido com uma complexidade de tempo de $O(\sqrt{N}\log N)$.</p>
<p>Para isso, inicialmente seja $v \coloneqq$ a menor potência de dois é pelo menos $\sqrt{N}$.</p>
<p><strong>Ideia</strong>: Seja $F(x) &#x3D; (vx+1)(vx+2) \cdots (vx+v) &#x3D; \prod\limits_{i&#x3D;1}^{v}(vx + i)$, $0 \le x \le v$. Note que $F(0) &#x3D; (1)(2)\cdots(v)$, $F(1) &#x3D; (v + 1)(v + 2)\cdots(2v),$ etc portanto se $N$ fosse divisível por $v$ conseguiríamos representar $N!$ apenas através de várias aplicações de $F(0) F(1) F(2) \cdots$, formalmente para representar $N!$ para um $N$ qualquer, seja $u &#x3D; max{\space j \in \mathbb{Z} \space | \space j \cdot v \le N \space } &#x3D; \Big\lfloor \dfrac{N}{v} \Big\rfloor$, então $N!$ pode ser representado como $N! &#x3D; F(0)F(1) \cdots F(u) \underbrace{(uv + 1) (uv + 2) \cdots (N)}_{O(1)} $. Logo o problema de computar $N!$ se reduz a construir o polinômio $F(x)$ e avaliá-lo rapidamente.</p>
<p><strong>Solução</strong>: Vamos definir um novo polinômio $f_d(x) &#x3D; (vx+1)(vx+2) \cdots (vx+d)$ e representá-lo através da sequência $A_d &#x3D; (f_d(0), f_d(1), \cdots, f_d(d))$.</p>
<p>O algoritmo essencialmente será computar $A_{2d}$ a partir de $A_{d}$ começando em $A_1$ até chegarmos em $A_v$. Se essa transição puder ser realizada em $O(d \log d)$ então todo o problema será resolvido em $O(\sqrt N \log N)$​.</p>
<p>Para realizar essa transição vamos definir outras três sequências $B_d, C_d$ e $D_d$ a partir de  $A_d$</p>
<ul>
<li>$A_d[x] &#x3D; \prod\limits_{i&#x3D;1}^{d}(vx + i)$​​</li>
<li>$B_d[x] &#x3D; \prod\limits_{i&#x3D;d+1}^{2d}(vx + i) &#x3D; \prod\limits_{i&#x3D;1}^{d}(vx + i + d) &#x3D;  \prod\limits_{i&#x3D;1}^{d}(v(x + \frac{d}{v}) + i) &#x3D; A_d[x + \frac{d}{v}]$</li>
<li>$C_d[x] &#x3D; \prod\limits_{i&#x3D;1}^{d}(v(x + d + 1) + i) &#x3D; A_d[x + d + 1]$</li>
<li>$D_d[x] &#x3D; \prod\limits_{i&#x3D;d+1}^{2d}(v(x + d + 1) + i) &#x3D; \prod\limits_{i&#x3D;1}^{d}(v(x + d + 1) + i + d) &#x3D; \prod\limits_{i&#x3D;1}^{d}(v(x + d + 1 + \frac{d}{v}) + i) &#x3D; A_d[x + d + 1 + \frac{d}{v}]$</li>
</ul>
<p>onde $0 \le x \le d$.​</p>
<p>Perceba que cada uma dessas outras sequências podem ser definidas através da sequência original, oque permite usar o deslocamento de pontos de amostragem para computar cada uma delas em $O(d \log d)$. Uma vez que cada uma delas foi computada, podemos construir $A_{2d}$ da seguinte maneira:</p>
<p>$ A_{2d}[x] &#x3D; \begin{cases} A_d[x] \cdot B_d[x], &amp; 0 \le x \le d\ C_d[x - (d + 1)] \cdot D_d[x - (d + 1)], &amp; d &lt; x \le 2d  \end{cases} $</p>
<p>$\blacksquare$</p>
<h4 id="Codigo-2"><a href="#Codigo-2" class="headerlink" title="Código"></a>Código</h4><p>A seguir o código que computa $N! \pmod {998244353}$, com exceção da função <code>sampling_points_shift</code>.  TODO: mudar esse código</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> modular = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">modular <span class="title">fact</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(v * v &lt; N) v *= <span class="number">2</span>;</span><br><span class="line">	vector&lt;modular&gt; A = &#123;<span class="number">1</span>, v+<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>; d&lt;v; d*=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> B = <span class="built_in">sampling_points_shift</span>(A, <span class="built_in">modular</span>(d)/v, A.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">auto</span> C = <span class="built_in">sampling_points_shift</span>(A, d+<span class="number">1</span>, A.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">auto</span> D = <span class="built_in">sampling_points_shift</span>(A, d+<span class="number">1</span> + <span class="built_in">modular</span>(d)/v, A.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=d; i++) A[i] *= B[i], C[i] *= D[i];</span><br><span class="line">		A.<span class="built_in">resize</span>(d+d+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=d+<span class="number">1</span>; i&lt;=d+d; i++) A[i] = C[i-d<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	modular ret = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i+v &lt;= N) ret *= A[i/v], i += v;</span><br><span class="line">	<span class="keyword">while</span>(i+<span class="number">1</span> &lt;= N) ret *= ++i;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios::badbit | ios::failbit);</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">fact</span>(N).<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Problemas-para-praticar"><a href="#Problemas-para-praticar" class="headerlink" title="Problemas para praticar"></a>Problemas para praticar</h1><h2 id="2023-2024-ICPC-Brazil-Subregional-Programming-Contest-K-K-for-More-K-for-Less"><a href="#2023-2024-ICPC-Brazil-Subregional-Programming-Contest-K-K-for-More-K-for-Less" class="headerlink" title="2023-2024 ICPC Brazil Subregional Programming Contest K - K for More, K for Less"></a><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104555/problem/K">2023-2024 ICPC Brazil Subregional Programming Contest K - K for More, K for Less</a></h2><h3 id="Problema-2"><a href="#Problema-2" class="headerlink" title="Problema"></a>Problema</h3><p>Dados dois polinômios $t(x)$ e $p(x)$, o problema é encontrar o polinômio $q(x)$ tal que $q(x) &#x3D; t(x+K) + p(x-K)$ .</p>
<h3 id="Explicacao-1"><a href="#Explicacao-1" class="headerlink" title="Explicação"></a>Explicação</h3><p>Este problema pode ser resolvido diretamente aplicando deslocamento de Taylor para encontrar $t$ e $p$.</p>
<h3 id="Codigo-3"><a href="#Codigo-3" class="headerlink" title="Código"></a>Código</h3><p>O código excluindo a função <code>taylor_shift</code> é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;mint&gt; <span class="title">t</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x, t[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x, p[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    f = <span class="built_in">taylor_shift</span>(t, k);</span><br><span class="line">    p = <span class="built_in">taylor_shift</span>(p, -k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (f[i] + p[i]).<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="solved-ac-Grand-Arena-3-Div1C-Intersection-Range-Sum"><a href="#solved-ac-Grand-Arena-3-Div1C-Intersection-Range-Sum" class="headerlink" title="solved.ac Grand Arena #3 Div1C - Intersection Range Sum "></a><a target="_blank" rel="noopener" href="https://www.acmicpc.net/problem/30808">solved.ac Grand Arena #3 Div1C - Intersection Range Sum </a></h2><h3 id="Explicacao-2"><a href="#Explicacao-2" class="headerlink" title="Explicação"></a>Explicação</h3><p>Vamos compactar as coordenadas e contar a contribuição de cada intervalo unitário.</p>
<p>Se o intervalo unitário $i$ tem comprimento $L_i$ e aparece em um conjunto de $C_i$, vamos adicionar $L_i$ a $X_{C_i}$.</p>
<p>Neste momento, a resposta correta para $k$ torna-se $\sum_\limits{k \leq i} \binom{i}{k} \cdot X_i$.</p>
<p>Se $f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N} X_i x^i$,</p>
<p>$f(x+1) &#x3D; \sum\limits_{i&#x3D;0}^{N} X_i (x+1)^i &#x3D; \sum\limits_{i&#x3D;0}^{N} \sum\limits_{k&#x3D;0}^{i} X_i \binom{i}{k} x^k$ 이므로,</p>
<p>O coeficiente de ordem $k$ de $f(x+1)$ é a resposta correta para $k$.</p>
<p>Agora usando o Deslocamento de Taylor podemos resolver em $O(N \log N)$.</p>
<h3 id="Codigo-4"><a href="#Codigo-4" class="headerlink" title="Código"></a>Código</h3><p>O código excluindo <code>polynomial_taylor_shift</code> é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> modular = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> l[<span class="number">300001</span>], r[<span class="number">300001</span>], C[<span class="number">600000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios::badbit | ios::failbit);</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; com;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		r[i]++; <span class="comment">// [l, r)</span></span><br><span class="line">		com.<span class="built_in">push_back</span>(l[i]);</span><br><span class="line">		com.<span class="built_in">push_back</span>(r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>());</span><br><span class="line">	com.<span class="built_in">erase</span>(<span class="built_in">unique</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>()), com.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		l[i] = <span class="built_in">lower_bound</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>(), l[i]) - com.<span class="built_in">begin</span>();</span><br><span class="line">		r[i] = <span class="built_in">lower_bound</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>(), r[i]) - com.<span class="built_in">begin</span>();</span><br><span class="line">		C[l[i]]++;</span><br><span class="line">		C[r[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;com.<span class="built_in">size</span>(); i++)</span><br><span class="line">		C[i] += C[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;modular&gt; <span class="title">X</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i+<span class="number">1</span>&lt;com.<span class="built_in">size</span>(); i++)</span><br><span class="line">		X[C[i]] += com[i+<span class="number">1</span>] - com[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> res = <span class="built_in">polynomial_taylor_shift</span>(X, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">		cout &lt;&lt; res[i].<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AtCoder-Grand-Contest-005-F-Many-Easy-Problems"><a href="#AtCoder-Grand-Contest-005-F-Many-Easy-Problems" class="headerlink" title="AtCoder Grand Contest 005 - F - Many Easy Problems"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc005/tasks/agc005_f">AtCoder Grand Contest 005 - F - Many Easy Problems</a></h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정점이 $N$ 개인 트리가 주어집니다.</p>
<p>각 $K &#x3D; 1, 2, \cdots, N$ 마다, 트리에서 서로 다른 $K$ 개의 정점을 고르는 모든 $\binom{N}{K}$가지 경우에 대해, $K$ 개의 정점을 모두 포함하는 최소 크기의 connected subgraph의 크기의 합을 $924844033$(소수)으로 나눈 나머지를 구해야 합니다. (크기는 정점 개수로 정의됩니다.)</p>
<p>$(2 \leq N \leq 200,000)$</p>
<h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>서브트리의 정점 개수가 $s$ 일 때 간선의 개수는 $s-1$ 개입니다. 각 간선의 기여도를 센 다음에 $\binom{N}{K}$는 따로 더해 줍시다.</p>
<p>간선을 지웠을 때 절단된 두 컴포넌트의 크기를 각각 $L, R$ 이라고 하면, $\binom{N}{K} - \binom{L}{K} - \binom{R}{K}$만큼이 답에 기여됩니다.</p>
<p>따라서 각 간선마다 $X_N$ 에 $1$ 을 더하고 $X_L, X_R$ 에 $1$ 을 뺀다면, $K$ 에 대한 정답은 $\sum_{K \leq i} \binom{i}{K} \cdot X_i$ 가 됩니다.</p>
<p>$f(x) &#x3D; \sum_{i&#x3D;0}^{N} X_i x^i$ 라 하면,</p>
<p>$f(x+1) &#x3D; \sum_{i&#x3D;0}^{N} X_i (x+1)^i &#x3D; \sum_{i&#x3D;0}^{N} \sum_{K&#x3D;0}^{i} X_i \binom{i}{K} x^K$ 이므로,</p>
<p>$f(x+1)$의 $K$ 차항의 계수가 $K$ 에 대한 정답이 됩니다.</p>
<p>이제 Taylor Shift를 사용하면 $O(N \log N)$에 해결할 수 있습니다.</p>
<h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><p>$924844033 &#x3D; 441 \cdot 2^{21} + 1$ 이기 때문에 AtCoder Library의 NTT를 사용할 수 있습니다.</p>
<p><code>polynomial_taylor_shift</code>를 제외한 코드는 아래와 같습니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> modular = static_modint&lt;<span class="number">924844033</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> sz[<span class="number">200001</span>];</span><br><span class="line">vector&lt;modular&gt; X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz[n] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> next : g[n])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (next == prev) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(next, n);</span><br><span class="line">		sz[n] += sz[next];</span><br><span class="line">		X[N]++;</span><br><span class="line">		X[sz[next]]--;</span><br><span class="line">		X[N-sz[next]]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios::badbit | ios::failbit);</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		g[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	X.<span class="built_in">resize</span>(N+<span class="number">1</span>);</span><br><span class="line">	X[N]++;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">auto</span> res = <span class="built_in">polynomial_taylor_shift</span>(X, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">		cout &lt;&lt; res[i].<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Referencias"><a href="#Referencias" class="headerlink" title="Referências"></a>Referências</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/77551">[Tutorial] Generating Functions in Competitive Programming (Part 2)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/115696">Shift of polynomial sampling points</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://hyperbolic.tistory.com/5">O que você pode fazer com operações polinomiais(Coreano)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://maspypy.com/%E5%A4%9A%E9%A0%85%E5%BC%8F%E3%83%BB%E5%BD%A2%E5%BC%8F%E7%9A%84%E3%81%B9%E3%81%8D%E7%B4%9A%E6%95%B0-%E9%AB%98%E9%80%9F%E3%81%AB%E8%A8%88%E7%AE%97%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%82%E3%81%AE">[Polinômios&#x2F;Séries de potências formais] Coisas que podem ser calculadas rapidamente(Coreano)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://nyaannyaan.github.io/library/fps/sample-point-shift.hpp">fps&#x2F;sample-point-shift.hpp - Nyaan’s Libraty</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://pedrov3.github.io/2024/04/24/Testando/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pedro Vinicius Sousa da Silva">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/Testando/" class="post-title-link" itemprop="url">Testando</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Postado em</span>
      

      <time title="Criado em: 2024-04-24 21:35:00 / Modificado em: 21:40:03" itemprop="dateCreated datePublished" datetime="2024-04-24T21:35:00-03:00">2024-04-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://pedrov3.github.io/2024/04/24/My-New-Post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pedro Vinicius Sousa da Silva">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/My-New-Post/" class="post-title-link" itemprop="url">My New Post</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Postado em</span>

      <time title="Criado em: 2024-04-24 20:59:27" itemprop="dateCreated datePublished" datetime="2024-04-24T20:59:27-03:00">2024-04-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://pedrov3.github.io/2024/04/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pedro Vinicius Sousa da Silva">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Postado em</span>

      <time title="Criado em: 2024-04-24 18:54:27" itemprop="dateCreated datePublished" datetime="2024-04-24T18:54:27-03:00">2024-04-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://pedrov3.github.io/2023/11/26/taylor-shift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pedro Vinicius Sousa da Silva">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/26/taylor-shift/" class="post-title-link" itemprop="url">Taylor Shift, Sampling Points Shift</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Postado em</span>

      <time title="Criado em: 2023-11-26 23:00:00" itemprop="dateCreated datePublished" datetime="2023-11-26T23:00:00-03:00">2023-11-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Editado em</span>
      <time title="Modificado em: 2024-04-24 21:40:01" itemprop="dateModified" datetime="2024-04-24T21:40:01-03:00">2024-04-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1 id="Visao-geral"><a href="#Visao-geral" class="headerlink" title="Visão geral"></a>Visão geral</h1><p>Fui inspirado a escrever este post porque tenho visto problemas ao usar o Polynomial Shift em diversas competições recentemente.</p>
<p>Encontrar um novo polinômio $f(x+c)$ dado o polinômio $f(x)$ e o inteiro $c$ é chamado <strong>deslocamento de Taylor</strong>.</p>
<p>Se o polinômio $f(x)$ de grau menor que $N$ estiver oculto e dados os valores $f(0), f(1), \cdots , f(N-1)$ e os inteiros $c$, $M$, então $f(c), f(c +1), \cdots, f(c+M-1)$ é chamado de <strong>deslocamento de pontos de amostragem</strong>.</p>
<p>Os dois problemas acima são frequentemente ferramentas úteis na resolução de problemas combinatórios. Ambos os problemas são muito lentos para serem resolvidos de forma simples, mas podem ser resolvidos de forma eficiente se a FFT for usada.</p>
<p>Este artigo cobre os seguintes tópicos:</p>
<ul>
<li><p>Calculo do deslocamento de Taylor para um polinômio de grau $N$ em $O(N \log N)$</p>
</li>
<li><p>Calcular mudança de pontos de amostragem em $O((N+M) \log (N+M))$</p>
</li>
<li><p>Calcular $(N!\pmod{998244353})$ em $O(\sqrt{N} \log N)$ utilizando o deslocamento de pontos de amostragem.</p>
</li>
<li><p>Resolução de problemas usando deslocamento de Taylor</p>
</li>
</ul>
<p>Este artigo foi escrito para ser fácil de ler, mesmo para aqueles que não sabem como a FFT funciona, neste caso, você pode usá-la como uma caixa preta. </p>
<h2 id="Polynomial-Taylor-Shift"><a href="#Polynomial-Taylor-Shift" class="headerlink" title="Polynomial Taylor Shift"></a><a target="_blank" rel="noopener" href="https://judge.yosupo.jp/problem/polynomial_taylor_shift">Polynomial Taylor Shift</a></h2><h3 id="Problema"><a href="#Problema" class="headerlink" title="Problema"></a>Problema</h3><p>Dada uma sequência $a &#x3D; (a_0, a_1, \cdots, a_{N-1})$ de comprimento $N$ e um inteiro $c$.</p>
<p>Vamos definir um polinômio $f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i x^i$ de grau $N-1$.</p>
<p>O objetivo é encontrar uma sequência $b &#x3D; (b_0, b_1, \cdots, b_{N-1})$ que satisfaz $f(x+c) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} b_i x^i$, como este números podem ser grandes, imprima módulo $998244353$.</p>
<p>Limites: $1 \leq N \leq 2^{19} &#x3D; 524288; 0 \leq c,a_i &lt; 998244353$</p>
<h3 id="Solucao"><a href="#Solucao" class="headerlink" title="Solução"></a>Solução</h3><p>O cálculo ingênuo em $O(N^2)$ é muito lento. Vamos expandir $f(x+c)$ e otimizá-lo através de várias manipulações de somatório para resolver em $O(n \log N)$.</p>
<p>Pelo teorema binomial:</p>
<p>$(a + b)^n  &#x3D; \sum\limits_{k&#x3D;0}^n\binom{n}{k}a^kb^{n-k}$,</p>
<p>Logo a partir da definição do polinômio $f$, podemos expandir no seguinte:</p>
<p>$f(x+c) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i (x+c)^i &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i  \Big( \sum\limits_ { j&#x3D;0}^{i} \binom{i}{j} x^j c^{i-j} \Big) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} \sum\limits_ { j&#x3D;0}^{i} a_i \binom{i}{j} x^j c^{i-j}&#x3D;$</p>
<p>$ &#x3D; \sum\limits_{i&#x3D;0}^{N-1}\sum\limits_{j&#x3D;0}^{i}a_i \dfrac{i! x^j c^{i-j}}{(i-j)!j!} &#x3D; $ </p>
<p>$ &#x3D; \sum\limits_{j&#x3D;0}^{N-1}\sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! x^j c^{i-j}}{(i-j)!j!} &#x3D; $ (A justificativa ilustrada na figura ??).</p>
<p>$ &#x3D; \sum\limits_{j&#x3D;0}^{N-1} \dfrac{x^j}{j!} \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!}$</p>
<p>Este somatório interno pode ser resolvido usando FFT, a explicação segue:</p>
<p>Queremos encontrar $C_j &#x3D; \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!}$ para  $0 \le j \le N-1$.</p>
<p>Para isso seja $A_i &#x3D; a_i \cdot i!$, $B_i &#x3D; \dfrac{c^i}{i!}$</p>
<p>Podemos reescrever $C_j$ como:</p>
<p>$C_j &#x3D; \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!} &#x3D; \sum\limits_{i&#x3D;j}^{N-1} A_i B_{i-j} &#x3D; \sum\limits_{i&#x3D;j}^{N-1}\overline{A}<em>{N-i-1}B</em>{i-j} &#x3D; (\overline{A} * B)_{N - j - 1}$</p>
<p>$\overline{A}$ denota o vetor $A$ revertido (de trás para frente).</p>
<p>Desse modo, podemos computar o vetor $C$ através de uma convolução entre o vetor $\overline{A}$ e $B$ em $O(N \log N)$ usando FFT e depois usar o vetor $C$ para encontrar a sequência $b$, já que $b_j &#x3D; \frac{C_j}{j!} $​.</p>
<h3 id="Codigo"><a href="#Codigo" class="headerlink" title="Código"></a>Código</h3><p><a target="_blank" rel="noopener" href="https://github.com/atcoder/ac-library/blob/master/document_en/convolution.md"><strong>Código de convolução da Biblioteca do Atcoder</strong></a>. O código usado é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atcoder/all&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> <span class="keyword">namespace</span> atcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;mint&gt; <span class="title">taylor_shift</span><span class="params">(vector&lt;mint&gt;&amp; a, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">fat</span><span class="params">(n)</span></span>;</span><br><span class="line">  fat[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    fat[i] = fat[i - <span class="number">1</span>] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">A</span><span class="params">(n)</span>, <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    A[i] = a[i] * fat[i];</span><br><span class="line">    B[i] = <span class="built_in">mint</span>(c).<span class="built_in">pow</span>(i) / fat[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(<span class="built_in">all</span>(A));</span><br><span class="line">  <span class="keyword">auto</span> retval = <span class="built_in">convolution</span>(A, B);</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    b[i] = retval[n - i - <span class="number">1</span>] / fat[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, c;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    a[i] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : <span class="built_in">taylor_shift</span>(a, c)) &#123;</span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Deslocamento-de-pontos-de-amostragem"><a href="#Deslocamento-de-pontos-de-amostragem" class="headerlink" title="Deslocamento de pontos de amostragem"></a><a target="_blank" rel="noopener" href="https://judge.yosupo.jp/problem/shift_of_sampling_points_of_polynomial">Deslocamento de pontos de amostragem</a></h2><h3 id="Problema-1"><a href="#Problema-1" class="headerlink" title="Problema"></a>Problema</h3><p>Um polinômio $f(x)$ de grau menor que $N$ está oculto são dados $N$ valores $f(0), f(1), \cdots, f(N-1)$ e dois inteiros $c ,M$​.</p>
<p>Calcule $f(c + k) \pmod{998244353}$  para $k &#x3D; 0, 1 , \cdots , M - 1$.</p>
<p>$(1 \leq N,M \leq 524288; 0 \leq c,f(i) &lt; 998244353)$</p>
<h3 id="Explicacao"><a href="#Explicacao" class="headerlink" title="Explicação"></a>Explicação</h3><blockquote>
<p> Você pode ver imediatamente que isso pode ser resolvido em $O((N+M) \log^2 (N+M))$ usando Interpolação de Lagrange e Avaliação Multiponto introduzidas em <a target="_blank" rel="noopener" href="https://infossm.github.io/blog/2019/06/16/Multipoint-evaluation/"><strong><a href="Coreano">1</a></strong></a> e no <a target="_blank" rel="noopener" href="https://infossm.github.io/blog/2019/09/14/factor/"><strong><a href="Coreano">2</a></strong></a>. No entanto, resolveremos este problema mais rapidamente, aproveitando as suas propriedades especiais.</p>
</blockquote>
<h4 id="Interpolacao"><a href="#Interpolacao" class="headerlink" title="Interpolação"></a>Interpolação</h4><p>De acordo com a interpolação de Lagrange temos:</p>
<p>$f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} f(i) \prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{x-j}{i-j }$</p>
<p>Note que  $\prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{x-j}{i-j}$ ($0 \leq i,x \leq N-1$) contribui com $1$ apenas quando $x &#x3D; i$, e $0$ caso contrário. </p>
<h4 id="Avaliacao"><a href="#Avaliacao" class="headerlink" title="Avaliação"></a>Avaliação</h4><p>Agora só precisamos encontrar $f(c+k) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} f(i) \prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{c+k-j}{i-j}$ para $0 \leq k &lt; M$​​.</p>
<p>O objetivo é manipular estes somatórios e produtórios de modo que seja possível  gerar essa sequência através da convolução de outras duas sequências.</p>
<p>Para isso </p>
<p>$f(c+k) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} f(i) \prod\limits_{j&#x3D;0, j \neq i}^{N-1} \frac{c+k-j}{i-j} &#x3D;\sum\limits_{i&#x3D;0}^{N-1}f(i)\dfrac{\dfrac{(c+k) (c + k - 1)\cdots(c+k-(N - 1))}{c+k-i}}{ (-1)^{(N - 1)-i} \cdot i! \cdot ((N - 1) - i)! } \boldsymbol{[c + k - i \neq 0]}&#x3D; $</p>
<p>$ &#x3D; (c+k)(c + k - 1)\cdots(c+k-(N-1)) \cdot \sum\limits_{i&#x3D;0}^{N-1}\dfrac{f(i)}{ (c+k-i) \cdot (-1)^{(N-1)-i} \cdot i!  \cdot ((N-1) - i)! } \boldsymbol{[c + k - i \neq 0]} &#x3D; $</p>
<p>$ &#x3D; \prod\limits_{i&#x3D;0}^{N-1}(c+k-i) \cdot \sum\limits_{i&#x3D;0}^{N-1}\dfrac{f(i)}{ (c+k-i) \cdot (-1)^{(N-1)-i} \cdot i!  \cdot ((N-1) - i)! } \boldsymbol{[c + k - i \neq 0]} &#x3D; $</p>
<p>$ &#x3D; \prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i) \cdot \sum\limits_{i&#x3D;0}^{N-1}\dfrac{f(i)}{ (c+k-i) \cdot (-1)^{(N-1)-i} \cdot i!  \cdot ((N-1) - i)! } \boldsymbol{[c + k - i \neq 0]}$</p>
<p>Podemos ignorar neste momento os produtos externos ao somatório e focar apenas nele. Neste caso podemos resolvê-lo usando FFT.</p>
<p>Se definirmos $A_i &#x3D; \begin{cases} \dfrac{f(i)}{((N-1) - i)! \cdot (-1)^{(N-1) - i} \cdot i!} &amp; j \le N - 1, \ 0 &amp; j &gt; N - 1 \end{cases}$  e</p>
<p>Agora podemos escrever $f(c + k)$ como:</p>
<p>$f(c + k) &#x3D; \prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i)  \sum\limits_{i&#x3D;0}^{N - 1 + k} A_i \cdot \dfrac{1}{(c + k - i)} $</p>
<p>Tomando $B_{N + k - i - 1} &#x3D; \dfrac{1}{c + k - i}$ então $B_i &#x3D; \dfrac{1}{c - N + i}$</p>
<p>Definindo $g(k) &#x3D; \sum\limits_{i&#x3D;0}^{N - 1 + M} A_i \cdot B_{N+k-i-1} &#x3D; (A * B)_{N+k-1}$​ , que está em uma forma computável através de FFT. </p>
<p>Finalizando o cálculo de $f(c + k)$ note que podemos computar o produtório $\prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i)$ em $O(1)$ da seguinte maneira:,</p>
<p>Assumindo que $(C - N + i) \neq 0$, seja $S[i] &#x3D; \prod\limits_{j&#x3D;1}^{i}(C - N + i)$, podemos computar o produtório acima da seguinte maneira $\prod\limits_{i&#x3D;k+1}^{N+k}(c - N + i) &#x3D; \dfrac{S[N + k]}{s[k]}$. </p>
<ul>
<li>não dá pra assumir que $(C - N + i)$ já que pode acontecer</li>
<li>preciso</li>
</ul>
<h3 id="Codigo-1"><a href="#Codigo-1" class="headerlink" title="Código"></a>Código</h3><p>O código está abaixo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atcoder/all&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> atcoder;</span><br><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;mint&gt; <span class="title">sampling_points_shift</span><span class="params">(<span class="type">const</span> vector&lt;mint&gt;&amp; f, mint c, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = f.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">fat</span><span class="params">(n + m)</span>, <span class="title">a</span><span class="params">(n + m)</span>, <span class="title">b</span><span class="params">(n + m)</span>, <span class="title">s</span><span class="params">(n + m)</span>, <span class="title">res</span><span class="params">(m)</span></span>;</span><br><span class="line">  fat[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + m; i++) fat[i] = fat[i - <span class="number">1</span>] * i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">      <span class="type">int</span> sign = ((n - <span class="number">1</span>) - i) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">      a[i] = (sign * f[i]) / (fat[(n - <span class="number">1</span>) - i] * fat[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    b[i] = ((c - n + i + <span class="number">1</span>) == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> / (c - n + i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + m; i++)</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] * <span class="built_in">max</span>((<span class="type">int</span>)(c - n + i).<span class="built_in">val</span>(), (<span class="type">int</span>)<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> retval = <span class="built_in">convolution</span>(a, b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((c + k).<span class="built_in">val</span>() &lt; n) &#123;</span><br><span class="line">      x = (c + k).<span class="built_in">val</span>();</span><br><span class="line">      <span class="keyword">if</span> (x + modint::<span class="built_in">mod</span>() &lt; n) <span class="keyword">continue</span>;<span class="comment">// small mod, two zero case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">-1</span>) res[k] = retval[n + k - <span class="number">1</span>] * s[n + k] / s[k]; <span class="comment">// non-zero case</span></span><br><span class="line">    <span class="keyword">else</span> res[k] = f[x]; <span class="comment">// zero-case</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m, c;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    f[i] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : <span class="built_in">sampling_points_shift</span>(f, c, m)) cout &lt;&lt; x.<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Exemplo-de-uso"><a href="#Exemplo-de-uso" class="headerlink" title="Exemplo de uso"></a>Exemplo de uso</h3><p>Usando deslocamento de pontos de amostragem, $N! \pmod{998244353}$ pode ser obtido com uma complexidade de tempo de $O(\sqrt{N}\log N)$.</p>
<p>Para isso, inicialmente seja $v \coloneqq$ a menor potência de dois é pelo menos $\sqrt{N}$.</p>
<p><strong>Ideia</strong>: Seja $F(x) &#x3D; (vx+1)(vx+2) \cdots (vx+v) &#x3D; \prod\limits_{i&#x3D;1}^{v}(vx + i)$, $0 \le x \le v$. Note que $F(0) &#x3D; (1)(2)\cdots(v)$, $F(1) &#x3D; (v + 1)(v + 2)\cdots(2v),$ etc portanto se $N$ fosse divisível por $v$ conseguiríamos representar $N!$ apenas através de várias aplicações de $F(0) F(1) F(2) \cdots$, formalmente para representar $N!$ para um $N$ qualquer, seja $u &#x3D; max{\space j \in \mathbb{Z} \space | \space j \cdot v \le N \space } &#x3D; \Big\lfloor \dfrac{N}{v} \Big\rfloor$, então $N!$ pode ser representado como $N! &#x3D; F(0)F(1) \cdots F(u) \underbrace{(uv + 1) (uv + 2) \cdots (N)}_{O(1)} $. Logo o problema de computar $N!$ se reduz a construir o polinômio $F(x)$ e avaliá-lo rapidamente.</p>
<p><strong>Solução</strong>: Vamos definir um novo polinômio $f_d(x) &#x3D; (vx+1)(vx+2) \cdots (vx+d)$ e representá-lo através da sequência $A_d &#x3D; (f_d(0), f_d(1), \cdots, f_d(d))$.</p>
<p>O algoritmo essencialmente será computar $A_{2d}$ a partir de $A_{d}$ começando em $A_1$ até chegarmos em $A_v$. Se essa transição puder ser realizada em $O(d \log d)$ então todo o problema será resolvido em $O(\sqrt N \log N)$​.</p>
<p>Para realizar essa transição vamos definir outras três sequências $B_d, C_d$ e $D_d$ a partir de  $A_d$ </p>
<ul>
<li>$A_d[x] &#x3D; \prod\limits_{i&#x3D;1}^{d}(vx + i)$​​       </li>
<li>$B_d[x] &#x3D; \prod\limits_{i&#x3D;d+1}^{2d}(vx + i) &#x3D; \prod\limits_{i&#x3D;1}^{d}(vx + i + d) &#x3D;  \prod\limits_{i&#x3D;1}^{d}(v(x + \frac{d}{v}) + i) &#x3D; A_d[x + \frac{d}{v}]$ </li>
<li>$C_d[x] &#x3D; \prod\limits_{i&#x3D;1}^{d}(v(x + d + 1) + i) &#x3D; A_d[x + d + 1]$</li>
<li>$D_d[x] &#x3D; \prod\limits_{i&#x3D;d+1}^{2d}(v(x + d + 1) + i) &#x3D; \prod\limits_{i&#x3D;1}^{d}(v(x + d + 1) + i + d) &#x3D; \prod\limits_{i&#x3D;1}^{d}(v(x + d + 1 + \frac{d}{v}) + i) &#x3D; A_d[x + d + 1 + \frac{d}{v}]$</li>
</ul>
<p>onde $0 \le x \le d$.​</p>
<p>Perceba que cada uma dessas outras sequências podem ser definidas através da sequência original, oque permite usar o deslocamento de pontos de amostragem para computar cada uma delas em $O(d \log d)$. Uma vez que cada uma delas foi computada, podemos construir $A_{2d}$ da seguinte maneira:</p>
<p>$ A_{2d}[x] &#x3D; \begin{cases} A_d[x] \cdot B_d[x], &amp; 0 \le x \le d\ C_d[x - (d + 1)] \cdot D_d[x - (d + 1)], &amp; d &lt; x \le 2d  \end{cases} $</p>
<p>$\blacksquare$</p>
<h4 id="Codigo-2"><a href="#Codigo-2" class="headerlink" title="Código"></a>Código</h4><p>A seguir o código que computa $N! \pmod {998244353}$, com exceção da função <code>sampling_points_shift</code>.  TODO: mudar esse código</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> modular = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">modular <span class="title">fact</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(v * v &lt; N) v *= <span class="number">2</span>;</span><br><span class="line">	vector&lt;modular&gt; A = &#123;<span class="number">1</span>, v+<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>; d&lt;v; d*=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> B = <span class="built_in">sampling_points_shift</span>(A, <span class="built_in">modular</span>(d)/v, A.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">auto</span> C = <span class="built_in">sampling_points_shift</span>(A, d+<span class="number">1</span>, A.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">auto</span> D = <span class="built_in">sampling_points_shift</span>(A, d+<span class="number">1</span> + <span class="built_in">modular</span>(d)/v, A.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=d; i++) A[i] *= B[i], C[i] *= D[i];</span><br><span class="line">		A.<span class="built_in">resize</span>(d+d+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=d+<span class="number">1</span>; i&lt;=d+d; i++) A[i] = C[i-d<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	modular ret = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i+v &lt;= N) ret *= A[i/v], i += v;</span><br><span class="line">	<span class="keyword">while</span>(i+<span class="number">1</span> &lt;= N) ret *= ++i;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios::badbit | ios::failbit);</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">fact</span>(N).<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Problemas-para-praticar"><a href="#Problemas-para-praticar" class="headerlink" title="Problemas para praticar"></a>Problemas para praticar</h1><h2 id="2023-2024-ICPC-Brazil-Subregional-Programming-Contest-K-K-for-More-K-for-Less"><a href="#2023-2024-ICPC-Brazil-Subregional-Programming-Contest-K-K-for-More-K-for-Less" class="headerlink" title="2023-2024 ICPC Brazil Subregional Programming Contest K - K for More, K for Less"></a><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104555/problem/K">2023-2024 ICPC Brazil Subregional Programming Contest K - K for More, K for Less</a></h2><h3 id="Problema-2"><a href="#Problema-2" class="headerlink" title="Problema"></a>Problema</h3><p>Dados dois polinômios $t(x)$ e $p(x)$, o problema é encontrar o polinômio $q(x)$ tal que $q(x) &#x3D; t(x+K) + p(x-K)$ .</p>
<h3 id="Explicacao-1"><a href="#Explicacao-1" class="headerlink" title="Explicação"></a>Explicação</h3><p>Este problema pode ser resolvido diretamente aplicando deslocamento de Taylor para encontrar $t$ e $p$.</p>
<h3 id="Codigo-3"><a href="#Codigo-3" class="headerlink" title="Código"></a>Código</h3><p>O código excluindo a função <code>taylor_shift</code> é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;mint&gt; <span class="title">t</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x, t[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x, p[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    f = <span class="built_in">taylor_shift</span>(t, k);</span><br><span class="line">    p = <span class="built_in">taylor_shift</span>(p, -k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (f[i] + p[i]).<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="solved-ac-Grand-Arena-3-Div1C-Intersection-Range-Sum"><a href="#solved-ac-Grand-Arena-3-Div1C-Intersection-Range-Sum" class="headerlink" title="solved.ac Grand Arena #3 Div1C - Intersection Range Sum "></a><a target="_blank" rel="noopener" href="https://www.acmicpc.net/problem/30808">solved.ac Grand Arena #3 Div1C - Intersection Range Sum </a></h2><h3 id="Explicacao-2"><a href="#Explicacao-2" class="headerlink" title="Explicação"></a>Explicação</h3><p>Vamos compactar as coordenadas e contar a contribuição de cada intervalo unitário.</p>
<p>Se o intervalo unitário $i$ tem comprimento $L_i$ e aparece em um conjunto de $C_i$, vamos adicionar $L_i$ a $X_{C_i}$.</p>
<p>Neste momento, a resposta correta para $k$ torna-se $\sum_\limits{k \leq i} \binom{i}{k} \cdot X_i$.</p>
<p>Se $f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N} X_i x^i$,</p>
<p>$f(x+1) &#x3D; \sum\limits_{i&#x3D;0}^{N} X_i (x+1)^i &#x3D; \sum\limits_{i&#x3D;0}^{N} \sum\limits_{k&#x3D;0}^{i} X_i \binom{i}{k} x^k$ 이므로,</p>
<p>O coeficiente de ordem $k$ de $f(x+1)$ é a resposta correta para $k$.</p>
<p>Agora usando o Deslocamento de Taylor podemos resolver em $O(N \log N)$.</p>
<h3 id="Codigo-4"><a href="#Codigo-4" class="headerlink" title="Código"></a>Código</h3><p>O código excluindo <code>polynomial_taylor_shift</code> é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> modular = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> l[<span class="number">300001</span>], r[<span class="number">300001</span>], C[<span class="number">600000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios::badbit | ios::failbit);</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; com;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		r[i]++; <span class="comment">// [l, r)</span></span><br><span class="line">		com.<span class="built_in">push_back</span>(l[i]);</span><br><span class="line">		com.<span class="built_in">push_back</span>(r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>());</span><br><span class="line">	com.<span class="built_in">erase</span>(<span class="built_in">unique</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>()), com.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		l[i] = <span class="built_in">lower_bound</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>(), l[i]) - com.<span class="built_in">begin</span>();</span><br><span class="line">		r[i] = <span class="built_in">lower_bound</span>(com.<span class="built_in">begin</span>(), com.<span class="built_in">end</span>(), r[i]) - com.<span class="built_in">begin</span>();</span><br><span class="line">		C[l[i]]++;</span><br><span class="line">		C[r[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;com.<span class="built_in">size</span>(); i++)</span><br><span class="line">		C[i] += C[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;modular&gt; <span class="title">X</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i+<span class="number">1</span>&lt;com.<span class="built_in">size</span>(); i++)</span><br><span class="line">		X[C[i]] += com[i+<span class="number">1</span>] - com[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> res = <span class="built_in">polynomial_taylor_shift</span>(X, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">		cout &lt;&lt; res[i].<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AtCoder-Grand-Contest-005-F-Many-Easy-Problems"><a href="#AtCoder-Grand-Contest-005-F-Many-Easy-Problems" class="headerlink" title="AtCoder Grand Contest 005 - F - Many Easy Problems"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc005/tasks/agc005_f">AtCoder Grand Contest 005 - F - Many Easy Problems</a></h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정점이 $N$ 개인 트리가 주어집니다.</p>
<p>각 $K &#x3D; 1, 2, \cdots, N$ 마다, 트리에서 서로 다른 $K$ 개의 정점을 고르는 모든 $\binom{N}{K}$가지 경우에 대해, $K$ 개의 정점을 모두 포함하는 최소 크기의 connected subgraph의 크기의 합을 $924844033$(소수)으로 나눈 나머지를 구해야 합니다. (크기는 정점 개수로 정의됩니다.)</p>
<p>$(2 \leq N \leq 200,000)$</p>
<h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>서브트리의 정점 개수가 $s$ 일 때 간선의 개수는 $s-1$ 개입니다. 각 간선의 기여도를 센 다음에 $\binom{N}{K}$는 따로 더해 줍시다.</p>
<p>간선을 지웠을 때 절단된 두 컴포넌트의 크기를 각각 $L, R$ 이라고 하면, $\binom{N}{K} - \binom{L}{K} - \binom{R}{K}$만큼이 답에 기여됩니다.</p>
<p>따라서 각 간선마다 $X_N$ 에 $1$ 을 더하고 $X_L, X_R$ 에 $1$ 을 뺀다면, $K$ 에 대한 정답은 $\sum_{K \leq i} \binom{i}{K} \cdot X_i$ 가 됩니다.</p>
<p>$f(x) &#x3D; \sum_{i&#x3D;0}^{N} X_i x^i$ 라 하면,</p>
<p>$f(x+1) &#x3D; \sum_{i&#x3D;0}^{N} X_i (x+1)^i &#x3D; \sum_{i&#x3D;0}^{N} \sum_{K&#x3D;0}^{i} X_i \binom{i}{K} x^K$ 이므로,</p>
<p>$f(x+1)$의 $K$ 차항의 계수가 $K$ 에 대한 정답이 됩니다.</p>
<p>이제 Taylor Shift를 사용하면 $O(N \log N)$에 해결할 수 있습니다.</p>
<h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><p>$924844033 &#x3D; 441 \cdot 2^{21} + 1$ 이기 때문에 AtCoder Library의 NTT를 사용할 수 있습니다.</p>
<p><code>polynomial_taylor_shift</code>를 제외한 코드는 아래와 같습니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> modular = static_modint&lt;<span class="number">924844033</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> sz[<span class="number">200001</span>];</span><br><span class="line">vector&lt;modular&gt; X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz[n] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> next : g[n])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (next == prev) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(next, n);</span><br><span class="line">		sz[n] += sz[next];</span><br><span class="line">		X[N]++;</span><br><span class="line">		X[sz[next]]--;</span><br><span class="line">		X[N-sz[next]]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios::badbit | ios::failbit);</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		g[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	X.<span class="built_in">resize</span>(N+<span class="number">1</span>);</span><br><span class="line">	X[N]++;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">auto</span> res = <span class="built_in">polynomial_taylor_shift</span>(X, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">		cout &lt;&lt; res[i].<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Referencias"><a href="#Referencias" class="headerlink" title="Referências"></a>Referências</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/77551">[Tutorial] Generating Functions in Competitive Programming (Part 2)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/115696">Shift of polynomial sampling points</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://hyperbolic.tistory.com/5">O que você pode fazer com operações polinomiais(Coreano)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://maspypy.com/%E5%A4%9A%E9%A0%85%E5%BC%8F%E3%83%BB%E5%BD%A2%E5%BC%8F%E7%9A%84%E3%81%B9%E3%81%8D%E7%B4%9A%E6%95%B0-%E9%AB%98%E9%80%9F%E3%81%AB%E8%A8%88%E7%AE%97%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%82%E3%81%AE">[Polinômios&#x2F;Séries de potências formais] Coisas que podem ser calculadas rapidamente(Coreano)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://nyaannyaan.github.io/library/fps/sample-point-shift.hpp">fps&#x2F;sample-point-shift.hpp - Nyaan’s Libraty</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pedro Vinicius Sousa da Silva</span>
</div>
  <div class="powered-by">Feito com <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
