<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Resumo: Recorrências lineares</title>
    <url>/2024/05/24/Resumo-Recorrencias-lineares/</url>
    <content><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>Neste artigo faço um resumo de três teoremas de Matemática discreta sobre Recorrências lineares homogêneas e os aplico no problema <a href="https://judge.beecrowd.com/pt/problems/view/3413">BEE 3413 - Baita Desafio Complexo - Beecrowd</a> do contest da <a href="https://judge.beecrowd.com/pt/problems/origin/216">1ª Fase Zero da Maratona de Programação da SBC 2022&#x2F;2023</a>.</p>
<span id="more"></span>

<h2 id="Polinomio-caracteristico"><a href="#Polinomio-caracteristico" class="headerlink" title="Polinômio característico"></a>Polinômio característico</h2><p>Uma recorrência linear na forma:</p>
<p>$f(n) &#x3D; a_1 \cdot f(n-1) + a_2 \cdot f(n-2) + \cdots + a_k \cdot f(n - k)$</p>
<p>tem o seguinte polinômio característico:</p>
<p>$X^k &#x3D; a_1 \cdot X^{k-1} + a_2 \cdot X^{k-2} + \cdots + a_{k-1} \cdot X^1 + a_k \cdot X^0$</p>
<h2 id="Formula-fechada"><a href="#Formula-fechada" class="headerlink" title="Fórmula fechada"></a>Fórmula fechada</h2><p>Dado uma recorrência linear com polinômio característico igual a:</p>
<p>$(X - r_1)(X - r_1)(X - r_2)(X - r_3) &#x3D; 0$</p>
<p>tem fórmula fechada na forma:</p>
<p>$f(n) &#x3D; c_1 \cdot r_1^n + c_2 \cdot n \cdot r_1^n + c_3 \cdot r_2^n + c_4 \cdot r_3^n $</p>
<h2 id="Truque-da-soma-acumulada-de-Fibonacci"><a href="#Truque-da-soma-acumulada-de-Fibonacci" class="headerlink" title="Truque da soma acumulada de Fibonacci"></a>Truque da soma acumulada de Fibonacci</h2><p>Seja  $ f(n) &#x3D; \begin{cases}  n, &amp; \text{se  $n \le 1$}\\  f(n-1) + f(n-2), &amp; \text{caso contrário} \end{cases}$</p>
<p>A partir do fato que $f(n-2) &#x3D; f(n) - f(n-1)$ é o mesmo que $f(n) &#x3D; f(n + 2) - f(n+1)$</p>
<p>Podemos calcular $s(n) &#x3D; f(0) + f(1) + \dots + f(n)$, através da seguinte soma telescópica:</p>
<p>$f(0) &#x3D; f(2) - f(1)$</p>
<p>$f(1) &#x3D; f(3) - f(2)$</p>
<p>$f(2) &#x3D; f(4) - f(3)$​</p>
<p>​              $\cdots$</p>
<p>$f(n-1) &#x3D; f(n+1) - f(n)$</p>
<p>$f(n) &#x3D; f(n+2) - f(n+1)$</p>
<p>Somando essas igualdades temos:</p>
<p>$f(0) + f(1) + \cdots + f(n-1) + f(n) &#x3D; \Big(f(2) - f(1)\Big) + \Big(f(3) - f(2)\Big)  + \cdots + \Big( f(n+1) - f(n) \Big) + \Big( f(n+2) - f(n+1)\Big)$</p>
<p>$s(n) &#x3D; -f(1) + f(n+2)$</p>
<p>$s(n) &#x3D; f(n + 2) - f(1)$</p>
<h2 id="Problemas-para-praticar"><a href="#Problemas-para-praticar" class="headerlink" title="Problemas para praticar"></a>Problemas para praticar</h2><ul>
<li><a href="https://judge.beecrowd.com/pt/problems/view/3413">BEE 3413 - Baita Desafio Complexo - Beecrowd</a></li>
</ul>
<h3 id="Solucao"><a href="#Solucao" class="headerlink" title="Solução:"></a><strong>Solução:</strong></h3><p>Em resumo, nesse problema a parte principal de sua solução é aplicar os truques (1) e (2) ao contrário, ou seja, a partir de uma fórmula fechada encontrar a recorrência linear correspondente, uma vez que temos essa recorrência linear podemos computá-la em um ponto específico rapidamente usando exponenciação de matrizes (usando exponenciação binária) e para computar sua soma acumulada arrematamos o problema usando o truque (3). A seguir uma descrição mais detalhada.</p>
<p>A partir do truque (2) podemos notar que $f(n)$ do problema tem o formato de uma recorrência linear igual a:</p>
<p>$f(n) &#x3D; c_1 \cdot {\Big(\dfrac{1 + R}{2}\Big)}^n +  c_2 \cdot {\Big(\dfrac{1 - R}{2}\Big)}^n$</p>
<p>que por sua vez tem polinômio característico igual:</p>
<p>$\Big(X - \Big(\dfrac{1 + R}{2}\Big)\Big)\Big(X - \Big(\dfrac{1 - R}{2}\Big)\Big) &#x3D; 0$</p>
<p>expandindo essa equação temos:</p>
<p>$ \Big(X - \Big(\dfrac{1 + R}{2}\Big)\Big)\Big(X - \Big(\dfrac{1 - R}{2}\Big)\Big) &#x3D; X^2 - X \Big(\dfrac{1 - R}{2}\Big) - \Big(\dfrac{1 + R}{2}\Big) X  + \Big(\dfrac{1 + R}{2}\Big) \Big(\dfrac{1 - R}{2}\Big) &#x3D; $</p>
<p>$&#x3D; X^2 - X\Big(\dfrac{1 - R + 1 + R}{2}\Big) + \dfrac{1 - R^2}{4} &#x3D; X^2 - X + \dfrac{1 - (i\cdot\sqrt{4T - 1})^2}{4} &#x3D; X^2 - X  + \dfrac{1 -(-1 \cdot (4T - 1))}{4} &#x3D; $</p>
<p>$&#x3D; X^2 - X + T &#x3D; 0$</p>
<p>que colocando no formato $X^2 &#x3D; X^1 - T \cdot X^0$ evidencia que podemos aplicar o truque (1) para descobrir que $f(n)$ tem a forma:</p>
<p>$f(n) &#x3D; f(n - 1) - T \cdot f(n - 2)$</p>
<p>Para nossa instância podemos verificar que $f(0) &#x3D; 0$ e $f(1) &#x3D; 1$, desse modo temos que $f(n)$ como descrito no enunciado é o mesmo que:</p>
<p>$f(n) &#x3D; \begin{cases} n , &amp; \text{se } n \le 1\\ f(n - 1) - T \cdot f(n - 2), &amp; \text{caso contrário}\end{cases}$</p>
<p>que pode ser computada através da seguinte transformação linear em $O(\log{n})$ usando exponenciação binária:</p>
<p>$ \begin{bmatrix}<br>f(n) \\<br>f(n-1)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>1 &amp; -T \\<br>1 &amp; 0<br>\end{bmatrix} \begin{bmatrix}<br>f(n-1)  \\<br>f(n-2)<br>\end{bmatrix}$</p>
<p>$ \begin{bmatrix}<br>f(n) \\<br>f(n-1)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>1 &amp; -T \\<br>1 &amp; 0<br>\end{bmatrix}^{n-1} \begin{bmatrix}<br>f(1)  \\<br>f(0)<br>\end{bmatrix}, \text{onde } n \ge 2$</p>
<p>Por fim, para computar $s(n) &#x3D; f(0) + f(1) + \dots + f(n)$ podemos aplicar o truque (3) da seguinte maneira:</p>
<p>A partir do fato que $-T \cdot f(n-2) &#x3D; f(n) - f(n-1)$ é o mesmo que $-T \cdot f(n) &#x3D; f(n + 2) - f(n+1)$</p>
<p>Podemos encontrar $s(n)$ através da seguinte soma telescópica:</p>
<p>$-T \cdot f(0) &#x3D; f(2) - f(1)$</p>
<p>$-T \cdot f(1) &#x3D; f(3) - f(2)$</p>
<p>$-T \cdot f(2) &#x3D; f(4) - f(3)$</p>
<p>​              $\cdots$</p>
<p>$-T \cdot f(n-1) &#x3D; f(n+1) - f(n)$</p>
<p>$-T \cdot f(n) &#x3D; f(n+2) - f(n+1)$</p>
<p>Somando essas igualdades temos:</p>
<p>$-T \cdot \Big(f(0) + f(1) + \cdots + f(n-1) + f(n) \Big) &#x3D; \Big(f(2) - f(1)\Big) + \Big(f(3) - f(2)\Big)  + \cdots + \Big( f(n+1) - f(n) \Big) + \Big( f(n+2) - f(n+1)\Big)$</p>
<p>$-T \cdot s(n) &#x3D; -f(1) + f(n+2)$</p>
<p>$s(n) &#x3D; \dfrac{f(n + 2) - f(1)}{-T}$</p>
<p>$\blacksquare$</p>
<h4 id="Codigo"><a href="#Codigo" class="headerlink" title="Código"></a>Código</h4><p>A seguir o código do problema, omitindo o código da <a href="https://github.com/pedrov3/competitive-programming-notebook/blob/main/expmatrix.cpp">exponenciação de matrizes</a>, <a href="https://github.com/pedrov3/competitive-programming-notebook/blob/main/expbin.cpp">exponenciação binária</a> e o restante do <a href="https://github.com/pedrov3/competitive-programming-notebook/blob/main/templates/cpp.cpp">template</a>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">Matrix <span class="title">base</span><span class="params">(&#123;&#123;<span class="number">1</span>, -t&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> retval = <span class="built_in">expbin</span>(base, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> retval[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> s = [&amp;](<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="comment">// inverso modular através do &#x27;Fermat&#x27;s little theorem&#x27;;</span></span><br><span class="line">        <span class="built_in">return</span> (<span class="built_in">f</span>(n + <span class="number">2</span>) - <span class="built_in">f</span>(<span class="number">1</span>)) * <span class="built_in">expbin</span>(-t, P - <span class="number">2</span>) </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vi <span class="title">a</span><span class="params">(m)</span></span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="type">int</span> l = *<span class="built_in">max_element</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">s</span>(l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a)&#123;</span><br><span class="line">        ans -= <span class="built_in">f</span>(x);</span><br><span class="line">        ans %= P;</span><br><span class="line">        ans += P;</span><br><span class="line">        ans %= P;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Referencias"><a href="#Referencias" class="headerlink" title="Referências"></a>Referências</h2><ul>
<li><a href="https://pessoal.dainf.ct.utfpr.edu.br/zatesko/icsd21.html#:~:text=AULA%206%3A%20Recorr%C3%AAncias%20lineares">Notas de aula de recorrências lineares do Profº Leandro Zatesko</a></li>
<li><a href="https://youtu.be/C1uwYwjYqdE?si=5NTejm-K9_rcsE3L&t=10787">Oficina {28set,9nov}22: Upsolving da 1ª Fase Zero da Maratona de Programação da SBC - A partir de 2 hr 59 min 47 seg</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>AtCoder ABC 355 E - Guess the Sum</title>
    <url>/2024/05/31/abc355e/</url>
    <content><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>O texto a seguir é uma tradução para português (com adições)  do <a href="https://atcoder.jp/contests/abc355/editorial/10079">editorial</a> do problema <a href="https://atcoder.jp/contests/abc355/tasks/abc355_e">ABC355 - E - Guess the sum</a> que até o momento não foi traduzido.</p>
<span id="more"></span>

<p>Inicialmente se você já tiver visto o problema <a href="https://atcoder.jp/contests/abc349/tasks/abc349_d">D - Divide Interval - ABC349</a> pode notar sua semelhança, principalmente pois o intervalo em que você pode fazer perguntas é igual uma árvore de segmentos. A diferença deste problema é que você pode subtrair, o que permite dividir o intervalo de consulta em um número menor de sub-intervalos. Por exemplo, para $N&#x3D;3, L&#x3D;1,R&#x3D;7$, se você dividir o intervalo de perguntas usando a solução do problema <a href="https://atcoder.jp/contests/abc349/tasks/abc349_d">ABC349D</a>, precisará fazer três perguntas: $A_1$, $A_2 + A_3$ e $A_4 + A_5 + A_6 + A_7$ . Por outro lado, poderíamos com apenas duas consultas obter a resposta, primeiro fazemos $A_0 + A_1 + A_2 + A_3 + A_4 + A_5 + A_6 + A_7$ e depois subtraímos $A_0$ para obter a resposta.</p>
<p>Deste modo, neste problema precisamos construir uma outra solução. A solução descrita a seguir é baseada no vetor de soma acumulada (soma de prefixo).</p>
<p>Para $l, r$ $(0 \le l, r \le 2^N)$ inteiros, defina $S(l,r)$​​​​ como:</p>
<p>$S(l, r) &#x3D; \begin{cases} 0, &amp; (l &#x3D; r)\\ \sum\limits_{i&#x3D;x}^{y-1}A_i, &amp; (l &lt; r)\\ -S(r, l) &amp; (l &gt; r) \end{cases}$</p>
<p>O que queremos é $S(L,R+1)$, restringido a realizar perguntas para $S(l, r)$ que seguem o formato $S(2^ij, 2^i(j + 1))$. Note que como pela definição anterior $S(l, r)$ está definido mesmo quando $l &gt; r$, temos que $S(2^i(j+1), 2^ij) &#x3D; -S(2^ij, 2^i(j + 1))$, como esta última é uma consulta válida, podemos assumir que $S(2^i(j + 1), 2 ^i j )$ também é uma pergunta válida.</p>
<p>A partir da definição de $S$, é possível verificar que $S(x, y)$ possui a propriedade transitiva, ou seja, se $S(x, y)$ e $S(y, z)$ são conhecidos, então $S(x, z)$ pode ser encontrado como $S(x, y) + S(y, z)$​.</p>
<p>Fazendo uso dessa propriedade podemos pensar em um grafo definido a partir de $S$. Note que um caminho de $u, v$ neste grafo irá representar $S(u, v)$. Formalmente,  seja $G$ um grafo direcionado onde $V(G) &#x3D; {0, 1, \dots, 2^N}$ e existe uma aresta $(u, v)$ se é possível realizar uma consulta de $u$ pra $v$ ou de $v$ para $u$.</p>
<p>Agora, considere dois vértices $u, v$ cuja distância mínima em $G$ é 2, $S(u, v)$ pode ser obtido através de duas perguntas. Seja $(u, w, v)$ um caminho mínimo de $u$ para $v$,  $S(u, v) &#x3D; S(u, w) + S(w, v)$, note que como existe uma aresta de $(u, w)$ e de $(w, v)$, ambas $S(u, w)$ e $S(w, v)$ são consultas válidas.</p>
<p>De forma geral, dados dois vértices $u, v$ cuja distância mínima em $G$ é igual a $d$, $S(u, v)$ pode ser encontrado fazendo exatamente $d$ perguntas.</p>
<p>Portanto, é suficiente encontrar o caminho mais curto de $L$ a $R$ no grafo G (com restauração). Como o número de vértices do grafo $G$ é $2^N + 1$ e o número de arestas é $2^{N + 1} - 1$, o caminho mais curto pode ser encontrado com uma complexidade computacional de $O (2^{N})$ usando BFS .</p>
<h2 id="Referencias"><a href="#Referencias" class="headerlink" title="Referências"></a>Referências</h2><ul>
<li><a href="https://atcoder.jp/contests/abc355/editorial/10079">E - Guess the Sum Editorial by toam</a></li>
</ul>
]]></content>
      <tags>
        <tag>BFS</tag>
        <tag>Soma de prefixo</tag>
      </tags>
  </entry>
  <entry>
    <title>Deslocamento de Taylor</title>
    <url>/2024/06/04/TaylorShift/</url>
    <content><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>Este artigo é uma breve explicação de uma técnica conhecida como Deslocamento de Taylor (<em>Polynomial Taylor Shift</em>), esta técnica é usada para essencialmente resolver o problema de dado um polinômio $f(x)$ e um inteiro $c$, encontrar um novo polinômio $f(x + c)$.</p>
<span id="more"></span>

<h2 id="Polynomial-Taylor-Shift"><a href="#Polynomial-Taylor-Shift" class="headerlink" title="Polynomial Taylor Shift"></a><a href="https://judge.yosupo.jp/problem/polynomial_taylor_shift">Polynomial Taylor Shift</a></h2><h3 id="Problema"><a href="#Problema" class="headerlink" title="Problema"></a>Problema</h3><p>Dada uma sequência $a &#x3D; (a_0, a_1, \cdots, a_{N-1})$ de comprimento $N$ e um inteiro $c$.</p>
<p>Vamos definir um polinômio $f(x) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i x^i$ de grau $N-1$.</p>
<p>O objetivo é encontrar uma sequência $b &#x3D; (b_0, b_1, \cdots, b_{N-1})$ que satisfaz $f(x+c) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} b_i x^i$, como os números dessa sequência podem ser grandes, imprima cada um deles módulo $998244353$.</p>
<p>Limites: $1 \leq N \leq 2^{19} &#x3D; 524288; 0 \leq c,a_i &lt; 998244353$</p>
<h3 id="Solucao"><a href="#Solucao" class="headerlink" title="Solução"></a>Solução</h3><p>Resumo: ideias diretas como usar a interpolação de Lagrange podem ser otimizadas para resolver esse problema em uma complexidade de tempo $\mathcal{O}(N^2)$, que ainda é insuficiente para os limites estabelecidos. A solução esperada para este problema tem complexidade de tempo $\mathcal{O}(N \log N)$ e consiste na expansão de $f(x+c)$, a partir de $f(x) &#x3D; \sum_{i&#x3D;0}^{N} a_i x^i$, em seguida através de várias manipulações de somatório é possível deixá-la em uma forma computável através de uma convolução entre duas sequências. Uma descrição mais formal é dada em seguida.</p>
<p>Pelo teorema binomial:</p>
<p>$(a + b)^n  &#x3D; \sum\limits_{k&#x3D;0}^n\binom{n}{k}a^kb^{n-k}$,</p>
<p>e pela definição de $f$ podemos expandir $f(x + c)$ no seguinte:</p>
<p>$f(x+c) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i (x+c)^i &#x3D; \sum\limits_{i&#x3D;0}^{N-1} a_i  \Big( \sum\limits_ { j&#x3D;0}^{i} \binom{i}{j} x^j c^{i-j} \Big) &#x3D; \sum\limits_{i&#x3D;0}^{N-1} \sum\limits_ { j&#x3D;0}^{i} a_i \binom{i}{j} x^j c^{i-j}&#x3D;$</p>
<p>$ &#x3D; \sum\limits_{i&#x3D;0}^{N-1}\sum\limits_{j&#x3D;0}^{i}a_i \dfrac{i! x^j c^{i-j}}{(i-j)!j!} &#x3D; $</p>
<p>$ &#x3D; \sum\limits_{j&#x3D;0}^{N-1}\sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! x^j c^{i-j}}{(i-j)!j!} &#x3D; $ (Justificativa ilustrada nas Figuras 1 e 2).</p>
<p>$ &#x3D; \sum\limits_{j&#x3D;0}^{N-1} \dfrac{x^j}{j!} \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!}$</p>
<p>Este somatório interno pode ser resolvido usando FFT, a explicação segue:</p>
<p>Queremos encontrar $C_j &#x3D; \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!}$ para  $0 \le j \le N-1$.</p>
<p>Para isso seja $A_i &#x3D; a_i \cdot i!$, $B_i &#x3D; \dfrac{c^i}{i!}$</p>
<p>Podemos reescrever $C_j$ como:</p>
<p>$ C_j &#x3D; \sum\limits_{i&#x3D;j}^{N-1}a_i \dfrac{i! c^{i - j}}{(i-j)!} &#x3D; \sum\limits_{i&#x3D;j}^{N-1} A_i B_{i-j} &#x3D; \sum\limits_{i&#x3D;j}^{N-1} \overline{A}‎_{N-i-1} B_{i-j} &#x3D; (\overline{A} * B)‎_{N - j - 1} $</p>
<p>$\overline{A}$ denota o vetor $A$ revertido (de trás para frente).</p>
<p>Desse modo, podemos computar o vetor $C$ através de uma convolução entre o vetor $\overline{A}$ e $B$ em $O(N \log N)$ usando FFT e depois usar o vetor $C$ para encontrar a sequência $b$, já que $b_j &#x3D; \frac{C_j}{j!} $​​​.</p>
<table>
<thead>
<tr>
<th align="center">Figura 1</th>
<th align="center">Figura 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/../figuras/taylor1.jpg" alt="figura2"></td>
<td align="center"><img src="/../figuras/taylor2.jpg" alt="figura1"></td>
</tr>
</tbody></table>
<h3 id="Codigo"><a href="#Codigo" class="headerlink" title="Código"></a>Código</h3><p>Abaixo a implementação do algoritmo. Este código faz uso da implementação de <a href="https://github.com/atcoder/ac-library/tree/master"><strong>convolução da Biblioteca do Atcoder</strong></a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atcoder/all&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">using</span> <span class="keyword">namespace</span> atcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;mint&gt; <span class="title">taylor_shift</span><span class="params">(vector&lt;mint&gt;&amp; a, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">fat</span><span class="params">(n)</span></span>;</span><br><span class="line">  fat[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    fat[i] = fat[i - <span class="number">1</span>] * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">A</span><span class="params">(n)</span>, <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    A[i] = a[i] * fat[i];</span><br><span class="line">    B[i] = <span class="built_in">mint</span>(c).<span class="built_in">pow</span>(i) / fat[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(<span class="built_in">all</span>(A));</span><br><span class="line">  <span class="keyword">auto</span> retval = <span class="built_in">convolution</span>(A, B);</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    b[i] = retval[n - i - <span class="number">1</span>] / fat[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, c;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="function">vector&lt;mint&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    a[i] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : <span class="built_in">taylor_shift</span>(a, c)) &#123;</span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exemplo-de-aplicacao"><a href="#Exemplo-de-aplicacao" class="headerlink" title="Exemplo de aplicação"></a>Exemplo de aplicação</h1><h2 id="2023-2024-ICPC-Brazil-Subregional-Programming-Contest-K-K-for-More-K-for-Less"><a href="#2023-2024-ICPC-Brazil-Subregional-Programming-Contest-K-K-for-More-K-for-Less" class="headerlink" title="2023-2024 ICPC Brazil Subregional Programming Contest K - K for More, K for Less"></a><a href="https://codeforces.com/gym/104555/problem/K">2023-2024 ICPC Brazil Subregional Programming Contest K - K for More, K for Less</a></h2><h3 id="Problema-1"><a href="#Problema-1" class="headerlink" title="Problema"></a>Problema</h3><p>Dados dois polinômios $t(x)$ e $p(x)$, o problema é encontrar o polinômio $q(x)$ tal que $q(x) &#x3D; t(x+K) + p(x-K)$ .</p>
<h3 id="Explicacao"><a href="#Explicacao" class="headerlink" title="Explicação"></a>Explicação</h3><p>Este problema pode ser resolvido diretamente aplicando deslocamento de Taylor para encontrar $t$ e $p$.</p>
<h3 id="Codigo-1"><a href="#Codigo-1" class="headerlink" title="Código"></a>Código</h3><p>O código excluindo a função <code>taylor_shift</code> é o seguinte.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;mint&gt; <span class="title">t</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x, t[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x, p[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    f = <span class="built_in">taylor_shift</span>(t, k);</span><br><span class="line">    p = <span class="built_in">taylor_shift</span>(p, -k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (f[i] + p[i]).<span class="built_in">val</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Referencias"><a href="#Referencias" class="headerlink" title="Referências"></a>Referências</h1><ul>
<li><a href="https://infossm.github.io/blog/2023/11/26/taylor-shift/">Taylor Shift, Sampling Points Shift</a></li>
</ul>
]]></content>
      <tags>
        <tag>FFT</tag>
        <tag>Matemática</tag>
      </tags>
  </entry>
</search>
